<html><head><title>xReact</title><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="author" content="Jichao Ouyang" /><meta name="description" content="Reactive x React = xReact" /><meta name="og:image" content="/img/poster.png" /><meta name="og:title" content="xReact" /><meta name="og:site_name" content="xReact" /><meta name="og:url" content="https://xreact.oyanglul.us/" /><meta name="og:type" content="website" /><meta name="og:description" content="Reactive x React = xReact" /><link rel="icon" type="image/png" href="/img/favicon.png" /><meta name="twitter:title" content="xReact" /><meta name="twitter:image" content="https://xreact.oyanglul.us/img/poster.png" /><meta name="twitter:description" content="Reactive x React = xReact" /><meta name="twitter:card" content="summary_large_image" /><meta name="twitter:site" content="@oyanglulu" /><link rel="icon" type="image/png" sizes="16x16" href="/img/favicon16x16.png" /><link rel="icon" type="image/png" sizes="24x24" href="/img/favicon24x24.png" /><link rel="icon" type="image/png" sizes="32x32" href="/img/favicon32x32.png" /><link rel="icon" type="image/png" sizes="48x48" href="/img/favicon48x48.png" /><link rel="icon" type="image/png" sizes="57x57" href="/img/favicon57x57.png" /><link rel="icon" type="image/png" sizes="60x60" href="/img/favicon60x60.png" /><link rel="icon" type="image/png" sizes="64x64" href="/img/favicon64x64.png" /><link rel="icon" type="image/png" sizes="70x70" href="/img/favicon70x70.png" /><link rel="icon" type="image/png" sizes="72x72" href="/img/favicon72x72.png" /><link rel="icon" type="image/png" sizes="76x76" href="/img/favicon76x76.png" /><link rel="icon" type="image/png" sizes="96x96" href="/img/favicon96x96.png" /><link rel="icon" type="image/png" sizes="114x114" href="/img/favicon114x114.png" /><link rel="icon" type="image/png" sizes="120x120" href="/img/favicon120x120.png" /><link rel="icon" type="image/png" sizes="128x128" href="/img/favicon128x128.png" /><link rel="icon" type="image/png" sizes="144x144" href="/img/favicon144x144.png" /><link rel="icon" type="image/png" sizes="150x150" href="/img/favicon150x150.png" /><link rel="icon" type="image/png" sizes="152x152" href="/img/favicon152x152.png" /><link rel="icon" type="image/png" sizes="196x196" href="/img/favicon196x196.png" /><link rel="icon" type="image/png" sizes="310x310" href="/img/favicon310x310.png" /><link rel="icon" type="image/png" sizes="310x150" href="/img/favicon310x150.png" /><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" /><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" /><link rel="stylesheet" href="/highlight/styles/default.css" /><link rel="stylesheet" href="/css/style.css" /><link rel="stylesheet" href="/css/palette.css" /><link rel="stylesheet" href="/css/codemirror.css" /><link rel="stylesheet" href="/css/kazari-style.css" /><link rel="stylesheet" href="/css/monokai.css" /><link rel="stylesheet" href="/css/override.css" /></head><body class="docs"><div id="wrapper"><div id="sidebar-wrapper"><ul id="sidebar" class="sidebar-nav"><li class="sidebar-brand"><a href="/" class="brand"><div class="brand-wrapper"><span>xReact</span></div></a></li><li><a href="/FRP-Best-Practice.html" class="">Functional Best Practice</a></li><li><a href="/Get-Started.html" class="">Quick Start</a></li><li><a href="/examples/fantasy.html" class="">Fantasy</a></li><li><a href="/typeclass.html" class=" active ">Typeclass</a></li><li><a href="/FAQ.html" class="">FAQ</a></li></ul></div><div id="page-content-wrapper"><div class="nav"><div class="container-fluid"><div class="row"><div class="col-lg-12"><div class="action-menu pull-left clearfix"><a href="#menu-toggle" id="menu-toggle"><i class="fa fa-bars" aria-hidden="true"></i></a></div><ul class="pull-right"><li id="gh-eyes-item" class="hidden-xs"><a href="https://github.com/reactive-react/xreact"><i class="fa fa-eye"></i><span>WATCH<span id="eyes" class="label label-default">--</span></span></a></li><li id="gh-stars-item" class="hidden-xs"><a href="https://github.com/reactive-react/xreact"><i class="fa fa-star-o"></i><span>STARS<span id="stars" class="label label-default">--</span></span></a></li><li><a href="#" onclick="shareSiteTwitter('xReact Reactive x React = xReact');"><i class="fa fa-twitter"></i></a></li><li><a href="#" onclick="shareSiteFacebook('xReact Reactive x React = xReact');"><i class="fa fa-facebook"></i></a></li><li><a href="#" onclick="shareSiteGoogle();"><i class="fa fa-google-plus"></i></a></li></ul></div></div></div></div><div id="content" data-github-owner="reactive-react" data-github-repo="xreact"><div class="content-wrapper"><section><p>Typeclass is kind of FP design pattern, you may have seen lot of typeclass in Haskell.</p>

<p>In OO, you may usually create a class for a data, and define some methods in the class to operate on data inside.</p>

<p>But in FP we would more likely to separate definition of data and definition of operation.</p>

<p>For Example if we have a data type <code class="highlighter-rouge">Xstream</code>, we just create the data type</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="kr">class</span> <span class="nx">Xstream</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="na">value</span><span class="p">:</span> <span class="nx">T</span>
  <span class="nx">constructor</span><span class="p">(</span><span class="na">v</span><span class="p">:</span> <span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">v</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>In OO, if we need Xstream can be map, we probably need it to implement a interface e.g. <code class="highlighter-rouge">Mapable</code></p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Mapable</span><span class="o">&lt;</span><span class="nx">A</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="nx">map</span><span class="o">&lt;</span><span class="nx">B</span><span class="o">&gt;</span><span class="p">(</span><span class="na">f</span><span class="p">:</span> <span class="p">(</span><span class="na">v</span><span class="p">:</span><span class="nx">A</span><span class="p">)</span><span class="o">=&gt;</span><span class="nx">B</span><span class="p">):</span> <span class="nx">Mapable</span><span class="o">&lt;</span><span class="nx">B</span><span class="o">&gt;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Now we need to <strong>Open</strong> class <code class="highlighter-rouge">Xstream</code> to implement Mapable, add a new method in.</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="kr">class</span> <span class="nx">Xstream</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="kr">implements</span> <span class="nx">Mapable</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="na">value</span><span class="p">:</span> <span class="nx">T</span>
  <span class="nx">constructor</span><span class="p">(</span><span class="na">v</span><span class="p">:</span> <span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">v</span>
  <span class="p">}</span>

  <span class="nx">map</span><span class="o">&lt;</span><span class="nx">B</span><span class="o">&gt;</span><span class="p">(</span><span class="na">f</span><span class="p">:</span> <span class="p">(</span><span class="na">v</span><span class="p">:</span> <span class="nx">T</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">B</span><span class="p">):</span> <span class="nx">Mapable</span><span class="o">&lt;</span><span class="nx">B</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nx">Xstream</span><span class="p">(</span><span class="nx">f</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">value</span><span class="p">))</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>What if we need to implement another interface, says Foldable, we need to open it again</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="kr">class</span> <span class="nx">Xstream</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="kr">implements</span> <span class="nx">Mapable</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="nx">Foldable</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
   <span class="p">...</span>
  <span class="nx">fold</span><span class="o">&lt;</span><span class="nx">B</span><span class="o">&gt;</span><span class="p">(</span><span class="na">f</span><span class="p">:(</span><span class="na">acc</span><span class="p">:</span><span class="nx">B</span><span class="p">,</span><span class="na">v</span><span class="p">:</span><span class="nx">T</span><span class="p">)</span><span class="o">=&gt;</span><span class="nx">B</span><span class="p">,</span> <span class="na">base</span><span class="p">:</span><span class="nx">B</span><span class="p">):</span><span class="nx">B</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">f</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span> <span class="nx">base</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Now you may see the problem, OO class is not open for adding new behavior, while FP typeclass reverse this situation.</p>

<h1 id="functor">Functor</h1>

<p>A Mapable interface in FP is called Functor typeclass, but in FP the relation is reverse, interface should define on datatype</p>

<p>instead of</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="kr">class</span> <span class="nx">Xstream</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="kr">implements</span> <span class="nx">Mapable</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{...}</span>
</code></pre>
</div>

<p>typeclass reverse the order of class and interface, so we have a new class that just implement the Functor instance of Xstream</p>

<p>here’s the Functor typeclass</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Functor</span><span class="o">&lt;</span><span class="nx">F</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="nx">map</span><span class="o">&lt;</span><span class="nx">A</span><span class="p">,</span> <span class="nx">B</span><span class="o">&gt;</span><span class="p">(</span><span class="na">f</span><span class="p">:</span> <span class="p">(</span><span class="na">a</span><span class="p">:</span> <span class="nx">A</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">B</span><span class="p">,</span> <span class="na">fa</span><span class="p">:</span> <span class="nx">F</span><span class="o">&lt;</span><span class="nx">A</span><span class="o">&gt;</span><span class="p">):</span> <span class="nx">F</span><span class="o">&lt;</span><span class="nx">B</span><span class="o">&gt;</span>
<span class="p">}</span>
</code></pre>
</div>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="kr">class</span> <span class="nx">XstreamFunctor</span> <span class="nx">implement</span> <span class="nx">Functor</span><span class="o">&lt;</span><span class="nx">Xstream</span><span class="o">&lt;</span><span class="nx">any</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
  <span class="nx">map</span><span class="o">&lt;</span><span class="nx">A</span><span class="p">,</span> <span class="nx">B</span><span class="o">&gt;</span><span class="p">(</span><span class="na">f</span><span class="p">:</span> <span class="p">(</span><span class="na">v</span><span class="p">:</span> <span class="nx">A</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">B</span><span class="p">,</span> <span class="na">fa</span><span class="p">:</span> <span class="nx">Xstream</span><span class="o">&lt;</span><span class="nx">A</span><span class="o">&gt;</span><span class="p">):</span> <span class="nx">Xstream</span><span class="o">&lt;</span><span class="nx">B</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nx">Xstream</span><span class="p">(</span><span class="nx">f</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">value</span><span class="p">))</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>And we can use the map function from Functor, instead of from Xstream itself</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="k">new</span> <span class="nx">XstreamFunctor</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">a</span><span class="p">)</span><span class="o">=&gt;</span><span class="nx">a</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="k">new</span> <span class="nx">Xstream</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
</code></pre>
</div>

<h2 id="higher-kind-type">Higher Kind Type</h2>

<p>The above code won’t compile in typescript, because there’s no Higher Kind Type(HKT) in Typescript, so in</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Functor</span><span class="o">&lt;</span><span class="nx">F</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="nx">map</span><span class="o">&lt;</span><span class="nx">A</span><span class="p">,</span> <span class="nx">B</span><span class="o">&gt;</span><span class="p">(</span><span class="na">f</span><span class="p">:</span> <span class="p">(</span><span class="na">a</span><span class="p">:</span> <span class="nx">A</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">B</span><span class="p">,</span> <span class="na">fa</span><span class="p">:</span> <span class="nx">F</span><span class="o">&lt;</span><span class="nx">A</span><span class="o">&gt;</span><span class="p">):</span> <span class="nx">F</span><span class="o">&lt;</span><span class="nx">B</span><span class="o">&gt;</span>
<span class="p">}</span>
</code></pre>
</div>

<p><code class="highlighter-rouge">F</code> is a HKT, because <code class="highlighter-rouge">F</code> is not a specify type, <code class="highlighter-rouge">F&lt;number&gt;</code> is a type, <code class="highlighter-rouge">F</code> is something higher than type <code class="highlighter-rouge">F&lt;number&gt;</code></p>

<p>similar to Higher Order Function</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">a</span><span class="p">(</span><span class="nx">b</span><span class="p">){</span>
  <span class="k">return</span> <span class="kd">function</span><span class="p">(){</span>
     <span class="nx">b</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p><code class="highlighter-rouge">a</code> is a higher order function, <code class="highlighter-rouge">a(1)</code> is a normal function.</p>

<p>Fortunately we can mimic HKT in Typescript with literal type, inspired by <a href="https://github.com/gcanti/fp-ts">https://github.com/gcanti/fp-ts</a></p>

<p>We’ll need a interface <code class="highlighter-rouge">_&lt;A&gt;</code> to store all the HKT as a Type Dictionary</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">_</span><span class="o">&lt;</span><span class="nx">A</span><span class="o">&gt;</span> <span class="p">{</span> <span class="p">}</span>
</code></pre>
</div>

<p>And <code class="highlighter-rouge">HKT</code> of all HKT type keys</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="nx">type</span> <span class="nx">HKT</span> <span class="o">=</span> <span class="nx">keyof</span> <span class="nx">_</span><span class="o">&lt;</span><span class="nx">any</span><span class="o">&gt;</span>
</code></pre>
</div>

<p>and <code class="highlighter-rouge">$&lt;F,A&gt;</code> type to find the HKT in dictionary</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="nx">type</span> <span class="nx">$</span><span class="o">&lt;</span><span class="nx">F</span> <span class="kr">extends</span> <span class="nx">HKT</span><span class="p">,</span> <span class="nx">A</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nx">_</span><span class="o">&lt;</span><span class="nx">A</span><span class="o">&gt;</span><span class="p">[</span><span class="nx">F</span><span class="p">]</span>
</code></pre>
</div>

<p>Welcome to <strong>Type Level Programming</strong>, all above is at type level, which will never compile to js and effect runtime</p>

<p>Let’s try implement Functor typeclass again</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Functor</span><span class="o">&lt;</span><span class="nx">F</span> <span class="kr">extends</span> <span class="nx">HKT</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="nx">map</span><span class="o">&lt;</span><span class="nx">A</span><span class="p">,</span> <span class="nx">B</span><span class="o">&gt;</span><span class="p">(</span><span class="na">f</span><span class="p">:</span> <span class="p">(</span><span class="na">a</span><span class="p">:</span> <span class="nx">A</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">B</span><span class="p">,</span> <span class="na">fa</span><span class="p">:</span> <span class="nx">$</span><span class="o">&lt;</span><span class="nx">F</span><span class="p">,</span> <span class="nx">A</span><span class="o">&gt;</span><span class="p">):</span> <span class="nx">$</span><span class="o">&lt;</span><span class="nx">F</span><span class="p">,</span> <span class="nx">B</span><span class="o">&gt;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>We can implement Xstream’s Functor instance right now</p>

<ol>
  <li>Declare <code class="highlighter-rouge">Xstream</code> as HKT, with key <code class="highlighter-rouge">"Xstream"</code></li>
</ol>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">_</span><span class="o">&lt;</span><span class="nx">A</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="s2">"Xstream"</span><span class="p">:</span> <span class="nx">Xstream</span><span class="o">&lt;</span><span class="nx">A</span><span class="o">&gt;</span>
<span class="p">}</span>
</code></pre>
</div>

<ol>
  <li>implements <code class="highlighter-rouge">Functor&lt;"Xstream"&gt;</code>, notice that although <code class="highlighter-rouge">"Xstream"</code> looks like</li>
</ol>

<p>a string, but actually it’s literal string type. So it’s still type safe, any other string place here will cause compiler error.</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="kr">class</span> <span class="nx">XstreamFunctor</span> <span class="kr">implements</span> <span class="nx">Functor</span><span class="o">&lt;</span><span class="s2">"Xstream"</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="nx">map</span><span class="o">&lt;</span><span class="nx">A</span><span class="p">,</span> <span class="nx">B</span><span class="o">&gt;</span><span class="p">(</span><span class="na">f</span><span class="p">:</span> <span class="p">(</span><span class="na">v</span><span class="p">:</span> <span class="nx">A</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">B</span><span class="p">,</span> <span class="na">fa</span><span class="p">:</span> <span class="nx">Xstream</span><span class="o">&lt;</span><span class="nx">A</span><span class="o">&gt;</span><span class="p">):</span> <span class="nx">Xstream</span><span class="o">&lt;</span><span class="nx">B</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nx">Xstream</span><span class="p">(</span><span class="nx">f</span><span class="p">(</span><span class="nx">fa</span><span class="p">.</span><span class="nx">value</span><span class="p">))</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<h2 id="polymorphism">Polymorphism</h2>

<p>But, what’s the point, we move <code class="highlighter-rouge">map</code> function from <code class="highlighter-rouge">Xstream</code> to another class, every time we have to create <code class="highlighter-rouge">XstreamFunctor</code> ‘s instance to use <code class="highlighter-rouge">map</code></p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="k">new</span> <span class="nx">XstreamFunctor</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">a</span><span class="o">=&gt;</span><span class="nx">a</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="k">new</span> <span class="nx">Xstream</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
</code></pre>
</div>

<p>what about polymorphism, what if there’s another functor instance <code class="highlighter-rouge">Ystream</code>.</p>

<p>How can we use just one <code class="highlighter-rouge">map</code> that can apply to any instance of Functor?</p>

<p>Ideally we should have a <code class="highlighter-rouge">map</code> function such as:</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">map</span><span class="o">&lt;</span><span class="nx">F</span> <span class="kr">extends</span> <span class="nx">FunctorInstance</span><span class="p">,</span> <span class="nx">A</span><span class="p">,</span> <span class="nx">B</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">f</span><span class="err">:</span> <span class="p">(</span><span class="nx">v</span><span class="err">:</span> <span class="nx">A</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">B</span><span class="p">,</span> <span class="nx">fa</span><span class="err">:</span> <span class="nx">$</span><span class="o">&lt;</span><span class="nx">F</span><span class="p">,</span> <span class="nx">A</span><span class="o">&gt;</span><span class="p">)</span><span class="err">:</span> <span class="nx">$</span><span class="o">&lt;</span><span class="nx">F</span><span class="p">,</span> <span class="nx">B</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nx">Functor</span><span class="o">&lt;</span><span class="nx">F</span><span class="o">&gt;</span><span class="p">().</span><span class="nx">map</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">fa</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
</div>

<p>But Typeclass type system is not good enough to figure out <code class="highlighter-rouge">new Functor&lt;F&gt;</code>, Typescript can’t find class <code class="highlighter-rouge">XstreamFunctor</code> class from <code class="highlighter-rouge">Functor&lt;"Xstream"&gt;</code>. it break the gap between type and value. In Scala, <code class="highlighter-rouge">implicit</code> will help you find a value from a type. but how can we find a value from a type?</p>

<p>similar to <code class="highlighter-rouge">_</code> type, we need a dictionary</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="nx">namespace</span> <span class="nx">Functor</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">Xstream</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">XstreamFunctor</span>
  <span class="kr">const</span> <span class="nx">Ystream</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">YstreamFunctor</span>
<span class="p">}</span>
</code></pre>
</div>

<p>then we can invoke different type of stream by</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="nx">Functor</span><span class="p">[</span><span class="s1">'Xstream'</span><span class="p">].</span><span class="nx">map</span><span class="p">(</span><span class="nx">a</span><span class="o">=&gt;</span><span class="nx">a</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="k">new</span> <span class="nx">Xstream</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="nx">Functor</span><span class="p">[</span><span class="s1">'Ystream'</span><span class="p">].</span><span class="nx">map</span><span class="p">(</span><span class="nx">a</span><span class="o">=&gt;</span><span class="nx">a</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="k">new</span> <span class="nx">Ystream</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
</code></pre>
</div>

<p>but ‘Xstream’ is string value here, not type. how can we convert a string type to a value?</p>

<p>before that, let’s continue implement <code class="highlighter-rouge">map</code> and see what’s missing</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="nx">type</span> <span class="nx">FunctorInstance</span> <span class="o">=</span> <span class="nx">keyof</span> <span class="k">typeof</span> <span class="nx">Functor</span>
</code></pre>
</div>

<p>In this case <code class="highlighter-rouge">FunctorInstance</code> is type <code class="highlighter-rouge">'Xstream' | 'Ystream'</code></p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">map</span><span class="o">&lt;</span><span class="nx">F</span> <span class="kr">extends</span> <span class="nx">FunctorInstance</span><span class="p">,</span> <span class="nx">A</span><span class="p">,</span> <span class="nx">B</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">f</span><span class="err">:</span> <span class="p">(</span><span class="nx">v</span><span class="err">:</span> <span class="nx">A</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">B</span><span class="p">,</span> <span class="nx">fa</span><span class="err">:</span> <span class="nx">$</span><span class="o">&lt;</span><span class="nx">F</span><span class="p">,</span> <span class="nx">A</span><span class="o">&gt;</span><span class="p">)</span><span class="err">:</span> <span class="nx">$</span><span class="o">&lt;</span><span class="nx">F</span><span class="p">,</span> <span class="nx">B</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">Functor</span><span class="p">[</span><span class="nx">F</span><span class="p">].</span><span class="nx">map</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">fa</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
</div>

<p>It still won’t compile. <code class="highlighter-rouge">Functor[F]</code> won’t work, as we can’t convert string literal type <code class="highlighter-rouge">F</code> to a string value in TypeScript.</p>

<p>It turn out to be impossible in TypeScript if we think about it. All Type will be wipe out while compile to JS.</p>

<p>There’s no way you can get the information of type <code class="highlighter-rouge">F</code> in JS.</p>

<p>If we think in another way, it is possible to get a type metadata from instance <code class="highlighter-rouge">fa</code> though.</p>

<p>For example it’s easy to get the name of class of <code class="highlighter-rouge">fa</code>, the constructor name should be <code class="highlighter-rouge">'Xstream'</code></p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">map</span><span class="o">&lt;</span><span class="nx">F</span> <span class="kr">extends</span> <span class="nx">FunctorInstance</span><span class="p">,</span> <span class="nx">A</span><span class="p">,</span> <span class="nx">B</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">f</span><span class="err">:</span> <span class="p">(</span><span class="nx">v</span><span class="err">:</span> <span class="nx">A</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">B</span><span class="p">,</span> <span class="nx">fa</span><span class="err">:</span> <span class="nx">$</span><span class="o">&lt;</span><span class="nx">F</span><span class="p">,</span> <span class="nx">A</span><span class="o">&gt;</span><span class="p">)</span><span class="err">:</span> <span class="nx">$</span><span class="o">&lt;</span><span class="nx">F</span><span class="p">,</span> <span class="nx">B</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">Functor</span><span class="p">[</span><span class="nx">fa</span><span class="p">.</span><span class="nx">constructor</span><span class="p">.</span><span class="nx">name</span> <span class="nx">as</span> <span class="nx">F</span><span class="p">].</span><span class="nx">map</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">fa</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Sadly TypeScript can’t compile this either. <code class="highlighter-rouge">Functor[fa.constructor.name as F]</code> could be <code class="highlighter-rouge">XstreamFunctor</code> or <code class="highlighter-rouge">YstreamFunctor</code>, <code class="highlighter-rouge">fa</code> could be <code class="highlighter-rouge">Xstream</code> or <code class="highlighter-rouge">Ystream</code>, the compiler though it could be possible that <code class="highlighter-rouge">Functor[fa.constructor.name as F]</code> is <code class="highlighter-rouge">XstreamFunctor</code> and <code class="highlighter-rouge">fa</code> is <code class="highlighter-rouge">Ystream</code></p>

<p>since we are sure that fa is one of <code class="highlighter-rouge">Xstream</code> and <code class="highlighter-rouge">Ystream</code>, the dictionary should definitely find the right map for the right type. We could very hacky just turn it to JS and skip stupid TypeScript check.</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">map</span><span class="o">&lt;</span><span class="nx">F</span> <span class="kr">extends</span> <span class="nx">FunctorInstance</span><span class="p">,</span> <span class="nx">A</span><span class="p">,</span> <span class="nx">B</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">f</span><span class="err">:</span> <span class="p">(</span><span class="nx">v</span><span class="err">:</span> <span class="nx">A</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">B</span><span class="p">,</span> <span class="nx">fa</span><span class="err">:</span> <span class="nx">$</span><span class="o">&lt;</span><span class="nx">F</span><span class="p">,</span> <span class="nx">A</span><span class="o">&gt;</span><span class="p">)</span><span class="err">:</span> <span class="nx">$</span><span class="o">&lt;</span><span class="nx">F</span><span class="p">,</span> <span class="nx">B</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span><span class="o">&lt;</span><span class="nx">any</span><span class="o">&gt;</span><span class="nx">Functor</span><span class="p">[</span><span class="nx">fa</span><span class="p">.</span><span class="nx">constructor</span><span class="p">.</span><span class="nx">name</span> <span class="nx">as</span> <span class="nx">F</span><span class="p">]).</span><span class="nx">map</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">fa</span><span class="p">)</span> <span class="nx">as</span> <span class="nx">$</span><span class="o">&lt;</span><span class="nx">F</span><span class="p">,</span> <span class="nx">B</span><span class="o">&gt;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Now let us try the polymorphic map on any functor</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="nx">map</span><span class="o">&lt;</span><span class="s2">"Xstream"</span><span class="p">,</span> <span class="nx">number</span><span class="p">,</span> <span class="nx">number</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">a</span><span class="o">=&gt;</span><span class="nx">a</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="k">new</span> <span class="nx">Xstream</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="nx">map</span><span class="o">&lt;</span><span class="s2">"Ystream"</span><span class="p">,</span> <span class="nx">number</span><span class="p">,</span> <span class="nx">number</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">a</span><span class="o">=&gt;</span><span class="nx">a</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="k">new</span> <span class="nx">Ystream</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
</code></pre>
</div>

<p>Everything works fine.</p>

<p>But the code won’t work if we minify it. you should already guess that when the code is minify, constructor name will not necessary be <code class="highlighter-rouge">Xstream</code>, it could be any simple letters.</p>

<h2 id="reflect-metadata">Reflect Metadata</h2>

<p>One of the proper solution would be tag the data type some meta information using <a href="https://github.com/rbuckton/reflect-metadata">Reflect Metadata</a>, a ECMA proposal not sure what stage it currently is, but anyway it’s easy to shim.</p>

<p>I just create two functions</p>

<ul>
  <li><code class="highlighter-rouge">datatype</code> for tagging constructor as some kind of data type.</li>
  <li><code class="highlighter-rouge">kind</code> to fetch the tag from a instance</li>
</ul>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">datatype</span><span class="p">(</span><span class="nx">name</span><span class="err">:</span> <span class="nx">string</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span><span class="nx">constructor</span><span class="err">:</span> <span class="nb">Function</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">Reflect</span><span class="p">.</span><span class="nx">defineMetadata</span><span class="p">(</span><span class="s1">'design:type'</span><span class="p">,</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">constructor</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">kind</span><span class="p">(</span><span class="na">target</span><span class="p">:</span> <span class="nx">any</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">getMetadata</span><span class="p">(</span><span class="s1">'design:type'</span><span class="p">,</span> <span class="nx">target</span><span class="p">.</span><span class="nx">constructor</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Tagging Xstream</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="nx">datatype</span><span class="p">(</span><span class="s1">'Xstream'</span><span class="p">)(</span><span class="nx">Xstream</span><span class="p">)</span>
</code></pre>
</div>

<p>or using decorator syntax when declare class</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="err">@</span><span class="nx">datatype</span><span class="p">(</span><span class="s1">'Xstream'</span><span class="p">)</span>
<span class="kr">class</span> <span class="nx">Xstream</span><span class="o">&lt;</span><span class="nx">A</span><span class="o">&gt;</span> <span class="p">{...}</span>
</code></pre>
</div>

<p>Finally, we have a proper polymorphic <code class="highlighter-rouge">map</code> for any functor instance</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">map</span><span class="o">&lt;</span><span class="nx">F</span> <span class="kr">extends</span> <span class="nx">FunctorInstance</span><span class="p">,</span> <span class="nx">A</span><span class="p">,</span> <span class="nx">B</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">f</span><span class="err">:</span> <span class="p">(</span><span class="nx">v</span><span class="err">:</span> <span class="nx">A</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">B</span><span class="p">,</span> <span class="nx">fa</span><span class="err">:</span> <span class="nx">$</span><span class="o">&lt;</span><span class="nx">F</span><span class="p">,</span> <span class="nx">A</span><span class="o">&gt;</span><span class="p">)</span><span class="err">:</span> <span class="nx">$</span><span class="o">&lt;</span><span class="nx">F</span><span class="p">,</span> <span class="nx">B</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span><span class="o">&lt;</span><span class="nx">any</span><span class="o">&gt;</span><span class="nx">Functor</span><span class="p">[</span><span class="nx">kind</span><span class="p">(</span><span class="nx">fa</span><span class="p">)</span> <span class="nx">as</span> <span class="nx">F</span><span class="p">]).</span><span class="nx">map</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">fa</span><span class="p">)</span> <span class="nx">as</span> <span class="nx">$</span><span class="o">&lt;</span><span class="nx">F</span><span class="p">,</span> <span class="nx">B</span><span class="o">&gt;</span>
<span class="p">}</span>
</code></pre>
</div>

<h1 id="cartesian">Cartesian</h1>

<p>With typeclass, now we can simply add another operation for <code class="highlighter-rouge">Xstream</code>, without changing any existing code.</p>

<p>The following code add a new Cartesian typeclass, which enable Xstream to be able to product.</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="nx">type</span> <span class="nx">CartesianInstances</span> <span class="o">=</span> <span class="nx">keyof</span> <span class="k">typeof</span> <span class="nx">Cartesian</span>

<span class="kr">interface</span> <span class="nx">Cartesian</span><span class="o">&lt;</span><span class="nx">F</span> <span class="kr">extends</span> <span class="nx">HKT</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="nx">product</span><span class="o">&lt;</span><span class="nx">A</span><span class="p">,</span> <span class="nx">B</span><span class="o">&gt;</span><span class="p">(</span><span class="na">fa</span><span class="p">:</span> <span class="nx">$</span><span class="o">&lt;</span><span class="nx">F</span><span class="p">,</span> <span class="nx">A</span><span class="o">&gt;</span><span class="p">,</span> <span class="na">fb</span><span class="p">:</span> <span class="nx">$</span><span class="o">&lt;</span><span class="nx">F</span><span class="p">,</span> <span class="nx">B</span><span class="o">&gt;</span><span class="p">):</span> <span class="nx">$</span><span class="o">&lt;</span><span class="nx">F</span><span class="p">,</span> <span class="p">[</span><span class="nx">A</span><span class="p">,</span> <span class="nx">B</span><span class="p">]</span><span class="o">&gt;</span>
<span class="p">}</span>

<span class="nx">namespace</span> <span class="nx">Cartesian</span> <span class="p">{</span>
  <span class="kr">export</span> <span class="kd">let</span> <span class="nx">Xstream</span><span class="err">:</span> <span class="nx">Cartesian</span><span class="o">&lt;</span><span class="s2">"Xstream"</span><span class="o">&gt;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">product</span><span class="o">&lt;</span><span class="nx">F</span> <span class="kr">extends</span> <span class="nx">CartesianInstances</span><span class="p">,</span> <span class="nx">A</span><span class="p">,</span> <span class="nx">B</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">fa</span><span class="err">:</span> <span class="nx">$</span><span class="o">&lt;</span><span class="nx">F</span><span class="p">,</span> <span class="nx">A</span><span class="o">&gt;</span><span class="p">,</span> <span class="nx">fb</span><span class="err">:</span> <span class="nx">$</span><span class="o">&lt;</span><span class="nx">F</span><span class="p">,</span> <span class="nx">B</span><span class="o">&gt;</span><span class="p">)</span><span class="err">:</span> <span class="nx">$</span><span class="o">&lt;</span><span class="nx">F</span><span class="p">,</span> <span class="p">[</span><span class="nx">A</span><span class="p">,</span> <span class="nx">B</span><span class="p">]</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">instance</span> <span class="o">=</span> <span class="p">(</span><span class="o">&lt;</span><span class="nx">any</span><span class="o">&gt;</span><span class="nx">Cartesian</span><span class="p">)[</span><span class="nx">kind</span><span class="p">(</span><span class="nx">fa</span><span class="p">)]</span>
  <span class="k">return</span> <span class="nx">instance</span><span class="p">.</span><span class="nx">product</span><span class="p">(</span><span class="nx">fa</span><span class="p">,</span> <span class="nx">fb</span><span class="p">)</span> <span class="nx">as</span> <span class="nx">$</span><span class="o">&lt;</span><span class="nx">F</span><span class="p">,</span> <span class="p">[</span><span class="nx">A</span><span class="p">,</span> <span class="nx">B</span><span class="p">]</span><span class="o">&gt;</span>
<span class="p">}</span>

<span class="c1">// Cartesian Xstream instance</span>
<span class="kr">class</span> <span class="nx">XstreamCartesian</span> <span class="kr">implements</span> <span class="nx">Cartesian</span><span class="o">&lt;</span><span class="s2">"Xstream"</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="nx">product</span><span class="o">&lt;</span><span class="nx">A</span><span class="p">,</span> <span class="nx">B</span><span class="o">&gt;</span><span class="p">(</span><span class="na">fa</span><span class="p">:</span> <span class="nx">Xstream</span><span class="o">&lt;</span><span class="nx">A</span><span class="o">&gt;</span><span class="p">,</span> <span class="na">fb</span><span class="p">:</span> <span class="nx">Xstream</span><span class="o">&lt;</span><span class="nx">B</span><span class="o">&gt;</span><span class="p">):</span> <span class="nx">Xstream</span><span class="o">&lt;</span><span class="p">[</span><span class="nx">A</span><span class="p">,</span> <span class="nx">B</span><span class="p">]</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nx">Xstream</span><span class="p">([</span><span class="nx">fa</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span> <span class="nx">fb</span><span class="p">.</span><span class="nx">value</span><span class="p">]</span> <span class="nx">as</span> <span class="p">[</span><span class="nx">A</span><span class="p">,</span> <span class="nx">B</span><span class="p">])</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nx">Cartesian</span><span class="p">.</span><span class="nx">Xstream</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">XstreamCartesian</span>

<span class="c1">// product of two Xstream</span>
<span class="nx">product</span><span class="o">&lt;</span><span class="s2">"Xstream"</span><span class="p">,</span> <span class="nx">number</span><span class="p">,</span> <span class="nx">number</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="nx">Xstream</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="k">new</span> <span class="nx">Xstream</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="c1">// =&gt; Xstream([1,2])</span>
</code></pre>
</div>

<h1 id="apply">Apply</h1>

<p>If your typeclass extends another, just simply do it, for instance Apply will need to extends Cartesian and Functor.</p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Apply</span><span class="o">&lt;</span><span class="nx">F</span> <span class="kr">extends</span> <span class="nx">HKT</span><span class="o">&gt;</span> <span class="kr">extends</span> <span class="nx">Cartesian</span><span class="o">&lt;</span><span class="nx">F</span><span class="o">&gt;</span><span class="p">,</span> <span class="nx">Functor</span><span class="o">&lt;</span><span class="nx">F</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="nx">ap</span><span class="o">&lt;</span><span class="nx">A</span><span class="p">,</span> <span class="nx">B</span><span class="o">&gt;</span><span class="p">(</span><span class="na">fab</span><span class="p">:</span> <span class="nx">$</span><span class="o">&lt;</span><span class="nx">F</span><span class="p">,</span> <span class="p">(</span><span class="na">a</span><span class="p">:</span> <span class="nx">A</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">B</span><span class="o">&gt;</span><span class="p">,</span> <span class="na">fa</span><span class="p">:</span> <span class="nx">$</span><span class="o">&lt;</span><span class="nx">F</span><span class="p">,</span> <span class="nx">A</span><span class="o">&gt;</span><span class="p">):</span> <span class="nx">$</span><span class="o">&lt;</span><span class="nx">F</span><span class="p">,</span> <span class="nx">B</span><span class="o">&gt;</span>
<span class="p">}</span>

<span class="nx">type</span> <span class="nx">ApplyInstances</span> <span class="o">=</span> <span class="nx">keyof</span> <span class="k">typeof</span> <span class="nx">Apply</span>

<span class="nx">namespace</span> <span class="nx">Apply</span> <span class="p">{</span>
  <span class="kr">export</span> <span class="kd">let</span> <span class="nx">Xstream</span><span class="err">:</span> <span class="nx">Apply</span><span class="o">&lt;</span><span class="s2">"Xstream"</span><span class="o">&gt;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">ap</span><span class="o">&lt;</span><span class="nx">F</span> <span class="kr">extends</span> <span class="nx">ApplyInstances</span><span class="p">,</span> <span class="nx">A</span><span class="p">,</span> <span class="nx">B</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">fab</span><span class="err">:</span> <span class="nx">$</span><span class="o">&lt;</span><span class="nx">F</span><span class="p">,</span> <span class="p">(</span><span class="nx">a</span><span class="err">:</span> <span class="nx">A</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">B</span><span class="o">&gt;</span><span class="p">,</span> <span class="nx">fa</span><span class="err">:</span> <span class="nx">$</span><span class="o">&lt;</span><span class="nx">F</span><span class="p">,</span> <span class="nx">A</span><span class="o">&gt;</span><span class="p">)</span><span class="err">:</span> <span class="nx">$</span><span class="o">&lt;</span><span class="nx">F</span><span class="p">,</span> <span class="nx">B</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">instance</span> <span class="o">=</span> <span class="p">(</span><span class="o">&lt;</span><span class="nx">any</span><span class="o">&gt;</span><span class="nx">Functor</span><span class="p">)[</span><span class="nx">kind</span><span class="p">(</span><span class="nx">fab</span><span class="p">)]</span>
  <span class="k">return</span> <span class="nx">instance</span><span class="p">.</span><span class="nx">ap</span><span class="p">(</span><span class="nx">fab</span><span class="p">,</span> <span class="nx">fa</span><span class="p">)</span> <span class="nx">as</span> <span class="nx">$</span><span class="o">&lt;</span><span class="nx">F</span><span class="p">,</span> <span class="nx">B</span><span class="o">&gt;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>But don’t forget to redirect it’s function, map from Functor and product from Cartesian.</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="kr">class</span> <span class="nx">XstreamApply</span> <span class="kr">implements</span> <span class="nx">Apply</span><span class="o">&lt;</span><span class="s2">"Xstream"</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="nx">ap</span><span class="o">&lt;</span><span class="nx">A</span><span class="p">,</span> <span class="nx">B</span><span class="o">&gt;</span><span class="p">(</span><span class="na">fab</span><span class="p">:</span> <span class="nx">Xstream</span><span class="o">&lt;</span><span class="p">(</span><span class="na">a</span><span class="p">:</span> <span class="nx">A</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">B</span><span class="o">&gt;</span><span class="p">,</span> <span class="na">fa</span><span class="p">:</span> <span class="nx">Xstream</span><span class="o">&lt;</span><span class="nx">A</span><span class="o">&gt;</span><span class="p">):</span> <span class="nx">Xstream</span><span class="o">&lt;</span><span class="nx">B</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nx">Xstream</span><span class="p">(</span><span class="nx">fab</span><span class="p">.</span><span class="nx">value</span><span class="p">(</span><span class="nx">fa</span><span class="p">.</span><span class="nx">value</span><span class="p">))</span>
  <span class="p">}</span>
  <span class="nx">map</span> <span class="o">=</span> <span class="nx">Functor</span><span class="p">.</span><span class="nx">Xstream</span><span class="p">.</span><span class="nx">map</span>
  <span class="nx">product</span> <span class="o">=</span> <span class="nx">Cartesian</span><span class="p">.</span><span class="nx">Xstream</span><span class="p">.</span><span class="nx">product</span>
<span class="p">}</span>
</code></pre>
</div>

<p>One of the most best part of typeclass is, again, unlike OO class, it’s very easy to add a new function to a datatype, without change any of existing code.</p>

<p>For instance we need a <code class="highlighter-rouge">ap2</code> function, you don’t need to bother changing any existing Apply or it’s instances. Just add <code class="highlighter-rouge">ap2</code> then all Apply instance will instantly work.</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="kr">export</span> <span class="kd">function</span> <span class="nx">ap2</span><span class="o">&lt;</span><span class="nx">F</span> <span class="kr">extends</span> <span class="nx">ApplyInstances</span><span class="p">,</span> <span class="nx">A</span><span class="p">,</span> <span class="nx">B</span><span class="p">,</span> <span class="nx">C</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">fabc</span><span class="err">:</span> <span class="nx">$</span><span class="o">&lt;</span><span class="nx">F</span><span class="p">,</span> <span class="p">(</span><span class="nx">a</span><span class="err">:</span> <span class="nx">A</span><span class="p">,</span> <span class="nx">b</span><span class="err">:</span> <span class="nx">B</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">C</span><span class="o">&gt;</span><span class="p">,</span> <span class="nx">fa</span><span class="err">:</span> <span class="nx">$</span><span class="o">&lt;</span><span class="nx">F</span><span class="p">,</span> <span class="nx">A</span><span class="o">&gt;</span><span class="p">,</span> <span class="nx">fb</span><span class="err">:</span> <span class="nx">$</span><span class="o">&lt;</span><span class="nx">F</span><span class="p">,</span> <span class="nx">B</span><span class="o">&gt;</span><span class="p">)</span><span class="err">:</span> <span class="nx">$</span><span class="o">&lt;</span><span class="nx">F</span><span class="p">,</span> <span class="nx">C</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="na">instance</span><span class="p">:</span> <span class="nx">any</span> <span class="o">=</span> <span class="nx">Apply</span><span class="p">[</span><span class="nx">kind</span><span class="p">(</span><span class="nx">fabc</span><span class="p">)</span> <span class="nx">as</span> <span class="nx">F</span><span class="p">]</span>
  <span class="k">return</span> <span class="nx">instance</span><span class="p">.</span><span class="nx">ap</span><span class="p">(</span>
    <span class="nx">instance</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span>
      <span class="p">(</span><span class="na">f</span><span class="p">:</span> <span class="p">(</span><span class="na">a</span><span class="p">:</span> <span class="nx">A</span><span class="p">,</span> <span class="na">b</span><span class="p">:</span> <span class="nx">B</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">C</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">(([</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">]:</span> <span class="p">[</span><span class="nx">A</span><span class="p">,</span> <span class="nx">B</span><span class="p">])</span> <span class="o">=&gt;</span> <span class="nx">f</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">))</span>
      <span class="p">,</span> <span class="nx">fabc</span><span class="p">)</span>
    <span class="p">,</span> <span class="nx">instance</span><span class="p">.</span><span class="nx">product</span><span class="p">(</span><span class="nx">fa</span><span class="p">,</span> <span class="nx">fb</span><span class="p">)</span>
  <span class="p">)</span> <span class="nx">as</span> <span class="nx">$</span><span class="o">&lt;</span><span class="nx">F</span><span class="p">,</span> <span class="nx">C</span><span class="o">&gt;</span>
<span class="p">}</span>
</code></pre>
</div>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="nx">ap2</span><span class="o">&lt;</span><span class="s2">"Xstream"</span><span class="p">,</span> <span class="nx">number</span><span class="p">,</span> <span class="nx">number</span><span class="p">,</span> <span class="nx">number</span><span class="o">&gt;</span><span class="p">(</span>
  <span class="k">new</span> <span class="nx">Xstream</span><span class="p">((</span><span class="nx">a</span><span class="err">:</span> <span class="nx">number</span><span class="p">,</span> <span class="nx">b</span><span class="err">:</span> <span class="nx">number</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span><span class="p">),</span>
  <span class="k">new</span> <span class="nx">Xstream</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span>
  <span class="k">new</span> <span class="nx">Xstream</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="p">)</span>
<span class="c1">// =&gt; Xstream(5)</span>
</code></pre>
</div>

<p>More about Typeclass in TypeScript, <a href="https://github.com/reactive-react/xreact/tree/6ac7c192cfb5186a74e36593c121901cddd2225d/src/fantasy/typeclasses">check out the source code in xreact…</a></p>
</section></div></div></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js"></script><script src="/highlight/highlight.pack.js"></script><script>hljs.configure({
languages:['scala','java','bash']
});
hljs.initHighlighting();
             </script><script>((window.gitter = {}).chat = {}).options = {
room: 'jcouyang/react-most'};</script><script src="https://sidecar.gitter.im/dist/sidecar.v1.js"></script><script src="/js/main.js"></script><script src="/js/kazari.js"></script><script>
$(document).ready(function() {
	kazari.KazariPlugin().decorateCode('https://scala-evaluator-212.herokuapp.com/eval', 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.S2F6YXJp.Jl2eqMfw8IakJF93PjxTbrf-8YUJgX5OoOfy5JHE8Yw', '', 'monokai')
})
    </script></body></html>